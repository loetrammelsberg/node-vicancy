'use strict';
var Response = require("http-response-object");
var Promise = require("promise");
var concat = require("concat-stream");
var ResponsePromise_1 = require("./ResponsePromise");
var handle_qs_1 = require("./handle-qs");
var _basicRequest = require("http-basic");
var caseless = require('caseless');
var basicRequest = _basicRequest;
function request(method, url, options) {
    return ResponsePromise_1["default"](new Promise(function (resolve, reject) {
        // check types of arguments
        if (typeof method !== 'string') {
            throw new TypeError('The method must be a string.');
        }
        if (typeof url !== 'string') {
            throw new TypeError('The URL/path must be a string.');
        }
        if (options == null) {
            options = {};
        }
        if (typeof options !== 'object') {
            throw new TypeError('Options must be an object (or null).');
        }
        method = method.toUpperCase();
        options.headers = options.headers || {};
        var headers = caseless(options.headers);
        // handle query string
        if (options.qs) {
            url = handle_qs_1["default"](url, options.qs);
        }
        // handle json body
        if (options.json) {
            options.body = JSON.stringify(options.json);
            headers.set('Content-Type', 'application/json');
        }
        var body = options.body ? options.body : new Buffer(0);
        if (typeof body === 'string')
            body = new Buffer(body);
        if (!Buffer.isBuffer(body)) {
            throw new TypeError('body should be a Buffer or a String');
        }
        if (!headers.has('Content-Length')) {
            headers.set('Content-Length', body.length);
        }
        var req = basicRequest(method, url, {
            allowRedirectHeaders: options.allowRedirectHeaders,
            headers: options.headers,
            followRedirects: options.followRedirects !== false,
            maxRedirects: options.maxRedirects,
            gzip: options.gzip !== false,
            cache: options.cache,
            timeout: options.timeout,
            socketTimeout: options.socketTimeout,
            retry: options.retry,
            retryDelay: options.retryDelay,
            maxRetries: options.maxRetries,
            isMatch: options.isMatch,
            isExpired: options.isExpired,
            canCache: options.canCache
        }, function (err, res) {
            if (err)
                return reject(err);
            res.body.on('error', reject);
            res.body.pipe(concat(function (body) {
                resolve(new Response(res.statusCode, res.headers, Array.isArray(body) ? new Buffer(0) : body, res.url));
            }));
        });
        if (req) {
            req.end(body);
        }
    }));
}
request._setBasicRequest = function (_basicRequest) { return basicRequest = _basicRequest; };
module.exports = request;
